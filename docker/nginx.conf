# =========================================================================
# nginx.conf — GOFR Console Production
#
# Serves the Vite-built SPA and reverse-proxies /api/* paths to the MCP
# backend containers on gofr-net.  Designed for the nginx:alpine image
# running as non-root (user nginx, listen 8080).
#
# Security hardening:
#   • No server tokens, strict MIME sniffing, frame/XSS headers
#   • Upstream timeouts capped; proxy buffers bounded
#   • SSE streaming support for MCP Streamable HTTP
#   • Rate limiting on API proxy (zone: api_limit)
# =========================================================================

worker_processes  auto;
pid               /var/run/nginx.pid;
error_log         /data/logs/nginx-error.log warn;

events {
    worker_connections  1024;
    multi_accept        on;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # ── Logging ──────────────────────────────────────────────────────────
    log_format main '$remote_addr - $remote_user [$time_local] '
                    '"$request" $status $body_bytes_sent '
                    '"$http_referer" "$http_user_agent" '
                    'rt=$request_time uct=$upstream_connect_time urt=$upstream_response_time';

    access_log  /data/logs/nginx-access.log main;

    # ── Performance ──────────────────────────────────────────────────────
    sendfile        on;
    tcp_nopush      on;
    tcp_nodelay     on;
    keepalive_timeout  65;
    types_hash_max_size 2048;
    client_max_body_size 10m;

    # ── Compression ──────────────────────────────────────────────────────
    gzip  on;
    gzip_vary on;
    gzip_proxied any;
    gzip_min_length 256;
    gzip_comp_level 5;
    gzip_types
        text/plain
        text/css
        text/javascript
        application/javascript
        application/json
        application/xml
        image/svg+xml
        font/woff2;

    # ── Security headers (applied globally) ──────────────────────────────
    server_tokens off;

    # ── Rate limiting for API proxy ──────────────────────────────────────
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=30r/s;

    # ── DNS resolver for runtime upstream resolution ─────────────────────
    # Using Docker's embedded DNS (127.0.0.11) so nginx resolves backend
    # hostnames at request time, not at startup.  This lets nginx start
    # even when MCP backends are not yet running.
    resolver 127.0.0.11 valid=30s ipv6=off;
    resolver_timeout 5s;

    # =====================================================================
    # Main server — port 8080 (non-root)
    # =====================================================================
    server {
        listen 8080;
        server_name _;
        root /usr/share/nginx/html;
        index index.html;

        # ── Security response headers ────────────────────────────────────
        add_header X-Content-Type-Options  "nosniff"       always;
        add_header X-Frame-Options         "SAMEORIGIN"    always;
        add_header X-XSS-Protection        "1; mode=block" always;
        add_header Referrer-Policy         "strict-origin-when-cross-origin" always;
        add_header Permissions-Policy      "camera=(), microphone=(), geolocation=()" always;

        # ── Health endpoint (for Docker / load-balancer probes) ──────────
        location = /health {
            access_log off;
            default_type application/json;
            return 200 '{"status":"ok","service":"gofr-console"}';
        }

        # ── Static assets: hashed filenames → immutable cache ────────────
        location /assets/ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            try_files $uri =404;
        }

        # ── Proxy: MCP backends ──────────────────────────────────────────
        # Shared proxy settings
        # SSE support: disable buffering so streamed events reach the
        # client immediately.  Read timeout set high for long-running
        # MCP tool calls (e.g. get_content with depth > 1).

        location /api/gofr-iq/ {
            limit_req zone=api_limit burst=20 nodelay;
            set $backend_iq http://gofr-iq-mcp:8080;
            rewrite ^/api/gofr-iq/(.*)$ /$1 break;
            proxy_pass $backend_iq;
            include /etc/nginx/proxy_params.conf;
        }

        location /api/gofr-doc/ {
            limit_req zone=api_limit burst=20 nodelay;
            set $backend_doc http://gofr-doc-mcp:8040;
            rewrite ^/api/gofr-doc/(.*)$ /$1 break;
            proxy_pass $backend_doc;
            include /etc/nginx/proxy_params.conf;
        }

        location /api/gofr-plot/ {
            limit_req zone=api_limit burst=20 nodelay;
            set $backend_plot http://gofr-plot-mcp:8050;
            rewrite ^/api/gofr-plot/(.*)$ /$1 break;
            proxy_pass $backend_plot;
            include /etc/nginx/proxy_params.conf;
        }

        location /api/gofr-np/ {
            limit_req zone=api_limit burst=20 nodelay;
            set $backend_np http://gofr-np-mcp:8060;
            rewrite ^/api/gofr-np/(.*)$ /$1 break;
            proxy_pass $backend_np;
            include /etc/nginx/proxy_params.conf;
        }

        location /api/gofr-dig/ {
            limit_req zone=api_limit burst=20 nodelay;
            set $backend_dig http://gofr-dig-mcp:8070;
            rewrite ^/api/gofr-dig/(.*)$ /$1 break;
            proxy_pass $backend_dig;
            include /etc/nginx/proxy_params.conf;
        }

        # ── SPA fallback — everything else serves index.html ─────────────
        location / {
            try_files $uri $uri/ /index.html;

            # Short cache for index.html itself (so new deploys propagate)
            location = /index.html {
                add_header Cache-Control "no-cache, no-store, must-revalidate";
                add_header Pragma "no-cache";
                expires 0;
            }
        }

        # Block dot-files (.env, .git, etc.)
        location ~ /\. {
            deny all;
            access_log off;
            log_not_found off;
        }
    }
}
